#' Default behaviour creates an ascending value. This is, the lower the value
#' the better the candidate is considered
#' If names are given in n it will overwrite the names in the vector if named
#' @export
ranking <- function(v, cnames = NULL, decreasing = FALSE) {


  # Validate the parameters ----------------------------------------------------

  if(!is.null(cnames) && !is.vector(cnames)) {
    stop("v argument must be a vector")
  }

  if(is.numeric(v)) {

    # Validate v ---------------------------------------------------------------
    has_names <- FALSE

    # A vector containing the names of the candidates given in cnames.
    # If it is valid, it will be assigned as the names of the candidates.
    # To be valid, all the values in cnames must be unique.
    # Also, it must be one name for each candidate.
    # If the v vector had names they will be ignored.
    if(!is.null(cnames)) {
      if(!is.vector(cnames)) {
        warning("cnames argument must be a vector")
      }
      else {
        if(!is.character(cnames)) {
          cnames <- as.character(cnames)
        }
        if(length(unique(cnames)) != length(cnames) || # different name
           length(cnames) != length(v)) { # one for each candidate
          warning("The values of cnames have been ignored because the name
                of each candidate must be unique.
                Default names has been autogenerated")
        }
        else {
          candidates_names <- cnames
          has_names <- TRUE
        }
      }

    }
    # If we are here it means that there are not valid names specified in n
    # or they are not given.
    # Now we have two different options. These are, if the vector v has or
    # hasn't names. If it has names and the names are valid they are used. If it
    # doesn't have names or they are invalid default names are given


    if(!is.null(names(v)) && !has_names) {

      candidates_names <- names(v)

      # all the candidates must have a different name
      # if the names of the vector are not suitable for the names of the
      # candidates a warning message is send and automatic values will be created
      if(length(unique(candidates_names)) != length(candidates_names)) {
        names(v) <- NULL
        warning("The names of the v vector
                  must be unique for each candidate.
                Default names has been autogenerated to
                accomplish this requirement.")
      }
      else {
        # the names of the vector are keeped
        has_names <- TRUE
      }
    }

    # if the vector does not have names and the param n is null, then the method
    # gives a name to each candidate with the format C1, C2, C3...
    if(!has_names) {
      candidates_names <- 1:length(v)
      candidates_names <- paste("C", candidates_names, sep = "")
    }

    names(v) <- candidates_names

    # Create the ranking -------------------------------------------------------

    # If there are not ties, the position of the element in the ranking is
    # the same that in the sorted vector.
    # If there are ties it is necessary to evaluate them element by element

    # Create the vector that will store the final ranking
    ranking <- rep(0, length(v))
    names(ranking) <- candidates_names

    # Sort the vector with the given criteria (ascending or descending)
    v <- sort(v, decreasing = decreasing)

    if(length(v) != length(unique(v))) {

      ordv <- rep(0, length(v))
      names(ordv) <- names(v)

      pos_ranking <- 1
      ordv[1] <- pos_ranking
      previous_elem <- v[1]
      for(index in 2:length(v)) {
        this_elem <- v[index]
        if(decreasing) {
          if(this_elem < previous_elem) {
            pos_ranking <- pos_ranking + 1
          }
        }
        else { # it can't be less cause they're ordered so this means it's equal
          if(this_elem > previous_elem) {
            pos_ranking <- pos_ranking + 1
          }
        }
        ordv[index] <- pos_ranking
        previous_elem <- v[index]
      }

    } # end of how to order if the vector has ties
    else { # no ties

      ordv <- 1:length(v)
      names(ordv) <- names(v)
    } # end of how to order if the vector has not ties
      # Recorro el vector, sustituyo el mejor número por un 1, que es la posición
      # continúo y sustituyo el número real por la misma posición si es igual al
      # de la posición anterior y si no incremento y luego sustituyo


      # ahora tengo que hacer coincidir el vector del ranking con la posición
      # original basándome en los nombres de las columnas
    indexes <- match(names(ordv), candidates_names)

    i <- 1
    for(elem in indexes) {
      ranking[elem] <- ordv[i]
      i <- i + 1
    }

  } # end of is.nuemric




  else if(is.character(v)) {
    # Validate unique candidates -----------------------------------------------
    ranking <- 1:length(v)
    # validate that the names are unique and if they are not: error
    names(ranking) <- v
  }

  else {
    stop("v argument must be a vector")
  }

  class(ranking) <- c("ranking", "numeric")
  return(ranking)
}

# Generic methods for the class ranking
#' @export
format.ranking <- function(ranking) {
  ranking <- sort(ranking)

  names <- as.character(names(ranking))
  gr <- names[1]
  for(i in 1:(length(ranking)-1)) {
    thisElem <- ranking[i]
    nextElem <- ranking[i+1]

    if(thisElem<nextElem) {
      gr <- paste(gr, '≻',names[i+1])
    }
    else { # this means the two rankings are equals
      gr <- paste(gr, '∼',names[i+1])
    }
  }

  #NextMethod() # for calling the print of the next class which is the vector
  return(gr)
}


# Generic methods for the class ranking
#' @export
print.ranking <- function(ranking) {
  r <- format.ranking(ranking)
  cat(r, "\n")
  #NextMethod() # for calling the print of the next class which is the vector
  invisible(r)
}

default.ranking <- function(ranking) {
  stop("Error: method not defined for the class ranking")
}

#' @export
is.ranking <- function(x) {
  #if(length(unique(names(x))) == length(x)){
    max_pos <- max(x)
    min_pos <- min(x)
    if(min_pos > 0 && max_pos > 0 &&
       max_pos <= length(x) && min_pos < length(x) &&
       all(x <= max_pos) && all(x >= min_pos) &&
       all(1:max_pos %in% x)) {
      #if(inherits(x, "ranking")) {
        return(TRUE)
      #}
    }
  #}
  return(FALSE)
}

#s <- "a > b ~ c > d > e"
#' Title
#'
#' @param string
#'
#' @return
#' @export
#'
parse_ranking <- function(string) {
  string <- str_replace_all(string, " ", "")
  candidates <- unlist(strsplit(string, ">|~"))
  candidates <- sort(candidates)
  ranking <- rep(0, length(candidates))
  names(ranking) <- candidates
  string <- strsplit(string, "")[[1]]

  pos <- 1
  for (elem in string) {
    if(elem == ">" || elem == "~") {
      if(elem == ">") {
        pos <- pos + 1
      }
    }
    else {
      ranking[which(names(ranking) == elem)] <- pos
    }

  }
  return(ranking(ranking))
}

