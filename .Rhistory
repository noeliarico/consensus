}
irv(por01)
#' Instant runoff voting
#'
#' @param profileOfRankings
#'
#' @return
#' @export
#'
#' @examples
irv <- function(profileOfRankings, break_ties = "random") {
rankings <- profileOfRankings$profileOfRankings
candidates <- profileOfRankings$candidates
ncandidates <- length(candidates)
results <- rep(0, length(candidates))
names(results) <- candidates
half_nvoters <- sum(profileOfRankings$numberOfVoters) / 2
pos <- ncandidates
for(i in 1:ncandidates-2) {
print(rankings)
# Count the times that the candidate has been ranked at the first position
times_first <- colSums(rankings == 1)
# The worse candidate (the one that has been ranked in the best position the min number of times)
worse <- which.min(times_first)
results[worse] <- pos
pos <- pos - 1
rankings <- rankings[,-worse]
rankings <- t(apply(rankings, 1, rerank))
}
return(results)
}
irv(por01)
#' Instant runoff voting
#'
#' @param profileOfRankings
#'
#' @return
#' @export
#'
#' @examples
irv <- function(profileOfRankings, break_ties = "random") {
rankings <- profileOfRankings$profileOfRankings
candidates <- profileOfRankings$candidates
ncandidates <- length(candidates)
results <- rep(0, length(candidates))
names(results) <- candidates
half_nvoters <- sum(profileOfRankings$numberOfVoters) / 2
pos <- ncandidates
for(i in 1:ncandidates-2) {
print(rankings)
# Count the times that the candidate has been ranked at the first position
times_first <- colSums(rankings == 1)
# The worse candidate (the one that has been ranked in the best position the min number of times)
worse <- which.min(times_first)
results[worse] <- pos
print(results)
pos <- pos - 1
rankings <- rankings[,-worse]
rankings <- t(apply(rankings, 1, rerank))
}
return(results)
}
irv(por01)
#' Instant runoff voting
#'
#' @param profileOfRankings
#'
#' @return
#' @export
#'
#' @examples
irv <- function(profileOfRankings, break_ties = "random") {
rankings <- profileOfRankings$profileOfRankings
candidates <- profileOfRankings$candidates
ncandidates <- length(candidates)
results <- rep(0, length(candidates))
names(results) <- candidates
half_nvoters <- sum(profileOfRankings$numberOfVoters) / 2
pos <- ncandidates
for(i in 1:(ncandidates-2)) {
print(rankings)
# Count the times that the candidate has been ranked at the first position
times_first <- colSums(rankings == 1)
# The worse candidate (the one that has been ranked in the best position the min number of times)
worse <- which.min(times_first)
results[worse] <- pos
print(results)
pos <- pos - 1
rankings <- rankings[,-worse]
rankings <- t(apply(rankings, 1, rerank))
}
return(results)
}
irv(por01)
#' Instant runoff voting
#'
#' @param profileOfRankings
#'
#' @return
#' @export
#'
#' @examples
irv <- function(profileOfRankings, break_ties = "random") {
rankings <- profileOfRankings$profileOfRankings
candidates <- profileOfRankings$candidates
ncandidates <- length(candidates)
results <- rep(0, length(candidates))
names(results) <- candidates
half_nvoters <- sum(profileOfRankings$numberOfVoters) / 2
pos <- ncandidates
for(i in 1:(ncandidates-1)) {
print(rankings)
# Count the times that the candidate has been ranked at the first position
times_first <- colSums(rankings == 1)
# The worse candidate (the one that has been ranked in the best position the min number of times)
worse <- which.min(times_first)
results[worse] <- pos
print(results)
pos <- pos - 1
rankings <- rankings[,-worse]
rankings <- t(apply(rankings, 1, rerank))
}
return(results)
}
irv(por01)
#' Instant runoff voting
#'
#' @param profileOfRankings
#'
#' @return
#' @export
#'
#' @examples
irv <- function(profileOfRankings, break_ties = "random") {
rankings <- profileOfRankings$profileOfRankings
candidates <- profileOfRankings$candidates
ncandidates <- length(candidates)
results <- rep(0, length(candidates))
names(results) <- candidates
half_nvoters <- sum(profileOfRankings$numberOfVoters) / 2
pos <- ncandidates
for(i in 1:(ncandidates-1)) {
print(rankings)
# Count the times that the candidate has been ranked at the first position
times_first <- colSums(rankings == 1)
# The worse candidate (the one that has been ranked in the best position the min number of times)
worse <- which.min(times_first)
results[worse] <- pos
print(results)
pos <- pos - 1
rankings <- rankings[,-worse]
if(i < (ncandidates-1)) {
rankings <- t(apply(rankings, 1, rerank))
}
}
return(results)
}
irv(por01)
#' Instant runoff voting
#'
#' @param profileOfRankings
#'
#' @return
#' @export
#'
#' @examples
irv <- function(profileOfRankings, break_ties = "random") {
rankings <- profileOfRankings$profileOfRankings
candidates <- profileOfRankings$candidates
ncandidates <- length(candidates)
results <- rep(0, length(candidates))
names(results) <- candidates
half_nvoters <- sum(profileOfRankings$numberOfVoters) / 2
pos <- ncandidates
for(i in 1:(ncandidates-1)) {
print(rankings)
# Count the times that the candidate has been ranked at the first position
times_first <- colSums(rankings == 1)
# The worse candidate (the one that has been ranked in the best position the min number of times)
worse <- which.min(times_first)
results[worse] <- pos
print(results)
pos <- pos - 1
rankings <- rankings[,-worse]
if(i < (ncandidates-1)) {
rankings <- t(apply(rankings, 1, rerank))
} else {
rankings[which.min(rankings)] <- 1
}
}
return(results)
}
irv(por01)
#' Instant runoff voting
#'
#' @param profileOfRankings
#'
#' @return
#' @export
#'
#' @examples
irv <- function(profileOfRankings, break_ties = "random") {
rankings <- profileOfRankings$profileOfRankings
candidates <- profileOfRankings$candidates
ncandidates <- length(candidates)
results <- rep(0, length(candidates))
names(results) <- candidates
half_nvoters <- sum(profileOfRankings$numberOfVoters) / 2
pos <- ncandidates
for(i in 1:(ncandidates-1)) {
print(rankings)
# Count the times that the candidate has been ranked at the first position
times_first <- colSums(rankings == 1)
# The worse candidate (the one that has been ranked in the best position the min number of times)
worse <- which.min(times_first)
results[worse] <- pos
print(results)
pos <- pos - 1
rankings <- rankings[,-worse]
if(i < (ncandidates-1)) {
rankings <- t(apply(rankings, 1, rerank))
} else {
results[which.min(results)] <- 1
}
}
return(results)
}
irv(por01)
m
m == 5
(m == 5) * (1:4)
(m == 7) * (1:4)
#' Instant runoff voting
#'
#' @param profileOfRankings
#'
#' @return
#' @export
#'
#' @examples
irv <- function(profileOfRankings, break_ties = "random") {
rankings <- profileOfRankings$profileOfRankings
candidates <- profileOfRankings$candidates
ncandidates <- length(candidates)
results <- rep(0, length(candidates))
names(results) <- candidates
nvoters <- sum(profileOfRankings$numberOfVoters)
pos <- ncandidates
for(i in 1:(ncandidates-1)) {
print(rankings)
# Count the times that the candidate has been ranked at the first position
times_first <- colSums((rankings == 1 * nvoters))
# The worse candidate (the one that has been ranked in the best position the min number of times)
worse <- which.min(times_first)
results[worse] <- pos
print(results)
pos <- pos - 1
rankings <- rankings[,-worse]
if(i < (ncandidates-1)) {
rankings <- t(apply(rankings, 1, rerank))
} else {
results[which.min(results)] <- 1
}
}
return(results)
}
irv(por01)
#' Instant runoff voting
#'
#' @param profileOfRankings
#'
#' @return
#' @export
#'
#' @examples
irv <- function(profileOfRankings, break_ties = "random") {
rankings <- profileOfRankings$profileOfRankings
candidates <- profileOfRankings$candidates
ncandidates <- length(candidates)
results <- rep(0, length(candidates))
names(results) <- candidates
nvoters <- sum(profileOfRankings$numberOfVoters)
pos <- ncandidates
for(i in 1:(ncandidates-1)) {
print(rankings)
# Count the times that the candidate has been ranked at the first position
times_first <- colSums((rankings == 1) * nvoters)
print(rankings == 1)
print((rankings == 1) * nvoters)
# The worse candidate (the one that has been ranked in the best position the min number of times)
worse <- which.min(times_first)
results[worse] <- pos
print(results)
pos <- pos - 1
rankings <- rankings[,-worse]
if(i < (ncandidates-1)) {
rankings <- t(apply(rankings, 1, rerank))
} else {
results[which.min(results)] <- 1
}
}
return(results)
}
irv(por01)
irv(por02)
por02
por03
irv(por03)
irv(por04)
library(consensus)
ppor08
por08
rm(list=ls())
library(consensus)
por08
por09
por10
por11
por12
por13
library(devtools)
use_data_raw("por13")
library(consensus)
por13
irv(por13)
document()
library(consensus)
irv(por13)
library(consensus)
por13
source('~/Desktop/Github/consensus/data-raw/por13.R', echo=TRUE)
library(tibble)
library(tidyverse)
librery(tidymodels)
library(tidymodels)
por13
source('~/Desktop/Github/consensus/data-raw/por13.R', echo=TRUE)
rm(por13)
por13
library(consensus)
por13
irv(por13)
toLatex(por13)
library(consensus)
library(consensus)
toLatex(por13)
source('~/Desktop/Github/consensus/data-raw/por13.R', echo=TRUE)
library(tibble)
library(tidyverse)
library(tidymodels)
por13
rm(list=ls())
library(consensus)
scorix(por01)
library(consensus)
por07
votrix(por07)
por04
por03
por02
por05
por06
por07
votrix(por07)
votrix(por04)
votrix(por01)
votrix(por01)
por01
ppor01
por07
votrix(por07)
por08
por09
votrix(por08)
por07
library(consensus)
por06
por07
por08
por09
votrix(por09)
tideman(por09)
tideman(por09, break_ties = "max")
tideman(por09)
tideman(por09)
tideman(por09)
tideman(por09, break_ties = "c ≻ b ≻ d ≻ a")
tideman(por09, break_ties = ranking(c("c ≻ b ≻ d ≻ a")))
por09
tideman(por09, break_ties = parse_ranking(c("c ≻ b ≻ d ≻ a")))
votrix(por01)
tideman(por01)
por01
votrix(por01)
v <- votrix(por01)
v <- votrix(por01)
ifelse(v > 7, TRUE, FALSE)
v <- votrix(por01)
ifelse(v >= 7, TRUE, FALSE)
rowSums(ifelse(v >= 7, TRUE, FALSE))
v <- votrix(por01)
rowSums(ifelse(v > 7, TRUE, FALSE))
votrix(por02)
votrix(por03)
votrix(por04)
votrix(por05)
votrix(por05)
votrix(por06)
votrix(por07)
votrix(por08)
por08
votrix(por08)
v <- votrix(por01)
(m <- ifelse(v >= 5, TRUE, FALSE))
for(i in 1:m) {
for(j in i:m) {
}
}
library(devtools)
use_c("condorcet")
pw <- votrix(por04)
ranking <- rep(0, 4)
names(ranking) <- colnames(pw)
to_explore_pos <- 0
candidates_to_explore <- 0
pw <- votrix(por04)
library(usethis)
use_build_ignore("mork_exact.R")
document()
library(devtools)
document()
use_build_ignore("R/mork_exact.R")
document()
use_build_ignore("R/mork_exact.R")
document()
document()
pw <- votrix(por04)
ranking <- rep(0, 4)
names(ranking) <- colnames(pw)
to_explore_pos <- 0
candidates_to_explore <- 0
mork_exact <- function(pw, ranking, level = 1) {
pre <- paste(rep("-", level), collapse = "")
cat(paste0(pre, " executing mork_exact in level ", level, "\n"))
print(ranking)
# Stop condition 1: the matrix has dimensions 2x2
if(ncol(pw) == level) {
# Return the candidate
ranking[which(ranking==0)] <- ncol(pw)
print(ranking)
return(FALSE)
}
# Elements to add to the queue to evaluate
rows <- rowSums(pw)
cols <- colSums(pw)
to_explore_indexes <- length(which((rows != 0) & (rows >= cols)))
to_explore_indexes <- sort((rows-cols)[1:to_explore_indexes], decreasing = TRUE, index.return=TRUE)$ix
print(tibble::tibble(candidate = names(ranking),
row = rows,
col = cols,
difference = rows-cols) %>% dplyr::arrange(desc(difference)))
print(to_explore_indexes)
# If there is any index left to explore
while(length(to_explore_indexes) >= 1) {
next_index <- to_explore_indexes[1]
# Add the index to the ranking
new_ranking <- ranking
new_ranking[next_index] <- level
# Remove the index from the matrix
new_pw <- pw
new_pw[next_index,] <- 0
new_pw[,next_index] <- 0
# Call recursively
mork_exact(new_pw, new_ranking, level+1)
# Remove the index from the list of indexes to explore
to_explore_indexes <- to_explore_indexes[-1]
cat(paste(pre, "candidates to explore:\n"))
print(to_explore_indexes)
}
cat(paste(pre, "no more candidates to explore in this level\n"))
}
mork_exact(pw, ranking)
mork_exact(pw, ranking)
document()
library(devtools)
document()
library(consensus)
rm(list=ls())
document()
document()
borda_count(por01)
v <- borda_count(por01)
v
class(v)
borda_count(por01, seeTrace = TRUE)
beatpath(por01)
por01
votrix(por02)
por02
votrix(por05)
scorix(por05)
por01
irv(por01)
library(consensus)
irv(por01)
document()
library(consensus)
irv(por01)
library(consensus)
irv(por01)
library(consensus)
irv(por01)
