# de la posición anterior y si no incremento y luego sustituyo
# ahora tengo que hacer coincidir el vector del ranking con la posición
# original basándome en los nombres de las columnas
indexes <- match(names(ordv), candidates)
i <- 1
for(elem in indexes) {
ranking[elem] <- ordv[i]
i <- i + 1
}
class(ranking) <- c("ranking", "numeric")
return(ranking)
}
# Generic methods for the class ranking
#' @export
print.ranking <- function(ranking) {
ranking <- sort(ranking)
names <- as.character(names(ranking))
gr <- names[1]
for(i in 1:(length(ranking)-1)) {
thisElem <- ranking[i]
nextElem <- ranking[i+1]
#print(paste('Comparing: ',thisElem,'--',nextElem))
if(thisElem<nextElem) {
gr <- paste(gr, '>',names[i+1])
}
else { # this means the two rankings are equals
gr <- paste(gr, '~',names[i+1])
}
}
cat(gr, "\n")
#NextMethod() # for calling the print of the next class which is the vector
return(gr)
}
default.ranking <- function(ranking) {
stop("Error: method not defined for the class ranking")
}
is.ranking <- function(x) inherits(x, "ranking")
points <- t(data$synthetic_data)
dpor <- data.frame()
for(pvalue in seq(1, 1000, 5)){
distances <- ranking(as.matrix(dist(points, method = "minkowski", p = pvalue))[1, -1])
dpor <- rbind(dpor, distances)
}
por <- profile_of_rankings(as.matrix(dpor))
por
scoring(por, method = "borda")
scoringc(por, method = "borda")
por
por
por
dyn.load("scoring.so")
scoring(por, method = "borda")
scoringc(por, method = "borda")
##' }
#' @param t only necessary when the \code{method} choosen is
#' @param verbose by default FALSE. Change to TRUE for seeing on the screen
#'                the workflow of the function
#'
#' @return the ranking generated after applying the ranking rule
#'
#' @examples
#'
#'
scoringc <- function(profileOfRankings, method = NULL, t = 1, verbose = FALSE, seePoints = FALSE) {
if(verbose) {
cat('Executing a scoring ranking rule...\n')
}
attname <- deparse(substitute(profileOfRankings))
# Split votes and rankings
splittedPOF <- split_profile_of_rankings(profileOfRankings)
# Get votes
votes <- splittedPOF$votes
# Get rankings
profileOfRankings <- splittedPOF$rankings
# Get the candidates
candidates <- splittedPOF$candidates
# Result vectors
v <- vector(length = ncol(profileOfRankings))
# For each ranking in the profile of rankings
for(i in 1:nrow(profileOfRankings)) {
numVotersRow <- votes[i]
ranking <- profileOfRankings[i,]
p <- calculatePoints(ranking, method, t, verbose, seePoints)
v <- v + (numVotersRow * p)
if(verbose) {
cat("-> The points for this ranking\n")
print(p)
cat("-> This ranking has ",numVotersRow," voters\n")
cat("-> The current value of the total points is:")
print(v)
}
}
if(seePoints) {
print(v)
}
ranking <- .C("pointsToRanking",
ranking = integer(length(v)),
nranking = as.integer(length(v)),
points = v)$ranking
names(ranking) <- names(profileOfRankings)
return(ranking(ranking))
}
scoring(por, method = "borda")
scoringc(por, method = "borda")
scoringc(por, method = "borda", T)
scoringc(por, method = "borda", seePoints = T)
scoring(por, method = "borda", seePoints = T)
##' }
#' @param t only necessary when the \code{method} choosen is
#' @param verbose by default FALSE. Change to TRUE for seeing on the screen
#'                the workflow of the function
#'
#' @return the ranking generated after applying the ranking rule
#'
#' @examples
#'
#'
scoringc <- function(profileOfRankings, method = NULL, t = 1, verbose = FALSE, seePoints = FALSE) {
if(verbose) {
cat('Executing a scoring ranking rule...\n')
}
attname <- deparse(substitute(profileOfRankings))
# Split votes and rankings
splittedPOF <- split_profile_of_rankings(profileOfRankings)
# Get votes
votes <- splittedPOF$votes
# Get rankings
profileOfRankings <- splittedPOF$rankings
# Get the candidates
candidates <- splittedPOF$candidates
# Result vectors
v <- vector(length = ncol(profileOfRankings))
# For each ranking in the profile of rankings
for(i in 1:nrow(profileOfRankings)) {
numVotersRow <- votes[i]
ranking <- profileOfRankings[i,]
p <- calculatePoints(ranking, method, t, verbose, seePoints)
v <- v + (numVotersRow * p)
if(verbose) {
cat("-> The points for this ranking\n")
print(p)
cat("-> This ranking has ",numVotersRow," voters\n")
cat("-> The current value of the total points is:")
print(v)
}
}
#if(seePoints) {
print(v)
#}
ranking <- .C("pointsToRanking",
ranking = integer(length(v)),
nranking = as.integer(length(v)),
points = v)$ranking
names(ranking) <- names(profileOfRankings)
return(ranking(ranking))
}
##' }
#' @param t only necessary when the \code{method} choosen is
#' @param verbose by default FALSE. Change to TRUE for seeing on the screen
#'                the workflow of the function
#'
#' @return the ranking generated after applying the ranking rule
#'
#' @examples
#'
#'
scoring <- function(profileOfRankings, method = NULL, t = 1, verbose = FALSE, seePoints = FALSE) {
if(verbose) {
cat('Executing a scoring ranking rule...\n')
}
attname <- deparse(substitute(profileOfRankings))
# Split votes and rankings
splittedPOF <- split_profile_of_rankings(profileOfRankings)
# Get votes
votes <- splittedPOF$votes
# Get rankings
profileOfRankings <- splittedPOF$rankings
# Get the candidates
candidates <- splittedPOF$candidates
# Result vectors
v <- vector(length = ncol(profileOfRankings))
names(v) <- names(profileOfRankings)
# For each ranking in the profile of rankings
for(i in 1:nrow(profileOfRankings)) {
numVotersRow <- votes[i]
ranking <- profileOfRankings[i,]
p <- calculatePoints(ranking, method, t, verbose, seePoints)
v <- v + (numVotersRow * p)
if(verbose) {
cat("-> The points for this ranking\n")
print(p)
cat("-> This ranking has ",numVotersRow," voters\n")
cat("-> The current value of the total points is:")
print(v)
}
}
#if(seePoints) {
print(v)
#}
v <- sort(v, decreasing = TRUE) # sort v from more votes to less
if(verbose) {
print(paste('Points rewarded by each candidate of the profile of rankings', "'", attname, "'"))
print(v)
print('Ranking:')
}
# vector that will store the final ranking
ranking <- rep(0, length(candidates))
names(ranking) <- candidates
pos <- 1 # position in the ranking
for(i in 1:(length(v)-1)) {
thisElem <- v[i]
nextElem <- v[i+1]
# ranking
index_of_candidate <- which(candidates == names(v)[i])
ranking[index_of_candidate] <- pos
if(thisElem > nextElem) {
pos <- pos + 1
}
# else, nothing -> this means the two rankings are equals
# so it's not necessary increment the position cause it will be tied
# with the previous element
}
ranking[which(candidates == names(v)[i+1])] <- pos
return(ranking(ranking))
}
scoring(por, method = "borda")
scoringc(por, method = "borda")
##' }
#' @param t only necessary when the \code{method} choosen is
#' @param verbose by default FALSE. Change to TRUE for seeing on the screen
#'                the workflow of the function
#'
#' @return the ranking generated after applying the ranking rule
#'
#' @examples
#'
#'
scoringc <- function(profileOfRankings, method = NULL, t = 1, verbose = FALSE, seePoints = FALSE) {
if(verbose) {
cat('Executing a scoring ranking rule...\n')
}
attname <- deparse(substitute(profileOfRankings))
# Split votes and rankings
splittedPOF <- split_profile_of_rankings(profileOfRankings)
# Get votes
votes <- splittedPOF$votes
# Get rankings
profileOfRankings <- splittedPOF$rankings
# Get the candidates
candidates <- splittedPOF$candidates
# Result vectors
v <- vector(length = ncol(profileOfRankings))
# For each ranking in the profile of rankings
for(i in 1:nrow(profileOfRankings)) {
numVotersRow <- votes[i]
ranking <- profileOfRankings[i,]
p <- calculatePoints(ranking, method, t, verbose, seePoints)
v <- v + (numVotersRow * p)
if(verbose) {
cat("-> The points for this ranking\n")
print(p)
cat("-> This ranking has ",numVotersRow," voters\n")
cat("-> The current value of the total points is:")
print(v)
}
}
#if(seePoints) {
print(v)
#}
print(integer(length(v)))
ranking <- .C("pointsToRanking",
ranking = integer(length(v)),
nranking = as.integer(length(v)),
points = v)$ranking
names(ranking) <- names(profileOfRankings)
return(ranking(ranking))
}
scoringc(por, method = "borda")
dyn.load("scoring.so")
scoringc(por, method = "borda")
dyn.load("scoring.so")
scoringc(por, method = "borda")
scoring(por, method = "borda")
dyn.load("scoring.so")
scoringc(por, method = "borda")
##' }
#' @param t only necessary when the \code{method} choosen is
#' @param verbose by default FALSE. Change to TRUE for seeing on the screen
#'                the workflow of the function
#'
#' @return the ranking generated after applying the ranking rule
#'
#' @examples
#'
#'
scoringc <- function(profileOfRankings, method = NULL, t = 1, verbose = FALSE, seePoints = FALSE) {
if(verbose) {
cat('Executing a scoring ranking rule...\n')
}
attname <- deparse(substitute(profileOfRankings))
# Split votes and rankings
splittedPOF <- split_profile_of_rankings(profileOfRankings)
# Get votes
votes <- splittedPOF$votes
# Get rankings
profileOfRankings <- splittedPOF$rankings
# Get the candidates
candidates <- splittedPOF$candidates
# Result vectors
v <- vector(length = ncol(profileOfRankings))
# For each ranking in the profile of rankings
for(i in 1:nrow(profileOfRankings)) {
numVotersRow <- votes[i]
ranking <- profileOfRankings[i,]
p <- calculatePoints(ranking, method, t, verbose, seePoints)
v <- v + (numVotersRow * p)
if(verbose) {
cat("-> The points for this ranking\n")
print(p)
cat("-> This ranking has ",numVotersRow," voters\n")
cat("-> The current value of the total points is:")
print(v)
}
}
#if(seePoints) {
print(v)
#}
print(integer(length(v)))
ranking <- .C("pointsToRanking",
ranking = integer(length(v)),
nranking = as.integer(length(v)),
points = as.double(v))$ranking
names(ranking) <- names(profileOfRankings)
return(ranking(ranking))
}
scoringc(por, method = "borda")
scoring(por, method = "borda")
library(rbenchmark)
benchmark(
"r" = {scoring(por, method = "borda")},
"c" = {scoringc(por, method = "borda")}
)
dyn.load("scoring.so")
benchmark(
"r" = {scoring(por, method = "borda")},
"c" = {scoringc(por, method = "borda")}
)
##' }
#' @param t only necessary when the \code{method} choosen is
#' @param verbose by default FALSE. Change to TRUE for seeing on the screen
#'                the workflow of the function
#'
#' @return the ranking generated after applying the ranking rule
#'
#' @examples
#'
#'
scoringc <- function(profileOfRankings, method = NULL, t = 1, verbose = FALSE, seePoints = FALSE) {
if(verbose) {
cat('Executing a scoring ranking rule...\n')
}
attname <- deparse(substitute(profileOfRankings))
# Split votes and rankings
splittedPOF <- split_profile_of_rankings(profileOfRankings)
# Get votes
votes <- splittedPOF$votes
# Get rankings
profileOfRankings <- splittedPOF$rankings
# Get the candidates
candidates <- splittedPOF$candidates
# Result vectors
v <- vector(length = ncol(profileOfRankings))
# For each ranking in the profile of rankings
for(i in 1:nrow(profileOfRankings)) {
numVotersRow <- votes[i]
ranking <- profileOfRankings[i,]
p <- calculatePoints(ranking, method, t, verbose, seePoints)
v <- v + (numVotersRow * p)
if(verbose) {
cat("-> The points for this ranking\n")
print(p)
cat("-> This ranking has ",numVotersRow," voters\n")
cat("-> The current value of the total points is:")
print(v)
}
}
#if(seePoints) {
#}
ranking <- .C("pointsToRanking",
ranking = integer(length(v)),
nranking = as.integer(length(v)),
points = as.double(v))$ranking
names(ranking) <- names(profileOfRankings)
return(ranking(ranking))
}
##' }
#' @param t only necessary when the \code{method} choosen is
#' @param verbose by default FALSE. Change to TRUE for seeing on the screen
#'                the workflow of the function
#'
#' @return the ranking generated after applying the ranking rule
#'
#' @examples
#'
#'
scoring <- function(profileOfRankings, method = NULL, t = 1, verbose = FALSE, seePoints = FALSE) {
if(verbose) {
cat('Executing a scoring ranking rule...\n')
}
attname <- deparse(substitute(profileOfRankings))
# Split votes and rankings
splittedPOF <- split_profile_of_rankings(profileOfRankings)
# Get votes
votes <- splittedPOF$votes
# Get rankings
profileOfRankings <- splittedPOF$rankings
# Get the candidates
candidates <- splittedPOF$candidates
# Result vectors
v <- vector(length = ncol(profileOfRankings))
names(v) <- names(profileOfRankings)
# For each ranking in the profile of rankings
for(i in 1:nrow(profileOfRankings)) {
numVotersRow <- votes[i]
ranking <- profileOfRankings[i,]
p <- calculatePoints(ranking, method, t, verbose, seePoints)
v <- v + (numVotersRow * p)
if(verbose) {
cat("-> The points for this ranking\n")
print(p)
cat("-> This ranking has ",numVotersRow," voters\n")
cat("-> The current value of the total points is:")
print(v)
}
}
#if(seePoints) {
#}
v <- sort(v, decreasing = TRUE) # sort v from more votes to less
if(verbose) {
print(paste('Points rewarded by each candidate of the profile of rankings', "'", attname, "'"))
print(v)
print('Ranking:')
}
# vector that will store the final ranking
ranking <- rep(0, length(candidates))
names(ranking) <- candidates
pos <- 1 # position in the ranking
for(i in 1:(length(v)-1)) {
thisElem <- v[i]
nextElem <- v[i+1]
# ranking
index_of_candidate <- which(candidates == names(v)[i])
ranking[index_of_candidate] <- pos
if(thisElem > nextElem) {
pos <- pos + 1
}
# else, nothing -> this means the two rankings are equals
# so it's not necessary increment the position cause it will be tied
# with the previous element
}
ranking[which(candidates == names(v)[i+1])] <- pos
return(ranking(ranking))
}
benchmark(
"r" = {scoring(por, method = "borda")},
"c" = {scoringc(por, method = "borda")}
)
data <- clusterlab(centers = 3, r = 1,
sdvec = c(0.5,0.5,1),
alphas = c(1, 2, 3),
numbervec = c(20, 20, 20),
features = 2)
points <- t(data$synthetic_data)
dpor <- data.frame()
for(pvalue in seq(1, 1000, 5)){
distances <- ranking(as.matrix(dist(points, method = "minkowski", p = pvalue))[1, -1])
dpor <- rbind(dpor, distances)
}
por <- profile_of_rankings(as.matrix(dpor))
benchmark(
"r" = {scoring(por, method = "borda")},
"c" = {scoringc(por, method = "borda")}
)
por
?inherits
x
x <- 2
inherits(x, "ranking")
inherits(x, "numeric")
ranking(c(3,4,2,1))
ranking(c(3,4,2,1), LETTERS[1:4])
dm <- ranking(c(1,2,3,4), LETTERS[1:4])
de <- ranking(c(1, 2, 4, 3), LETTERS[1:4])
dc <- ranking(c(1,2,3,4), LETTERS[1:4])
library(tidyverse)
tibble(dm, de, dc)
t(tibble(dm, de, dc))
tibble(~A, ~B, ~C, ~D,dm, de, dc))
tibble(~A, ~B, ~C, ~D,dm, de, dc))
tribble(~A, ~B, ~C, ~D,dm, de, dc))
tribble(~A, ~B, ~C, ~D,dm, de, dc)
tribble(~A, ~B, ~C, ~D,
1,2,3,4,
1,2,4,3,
1,2,3,4)
data <- tribble(~A, ~B, ~C, ~D,
1,2,3,4,
1,2,4,3,
1,2,3,4)
data
profile_of_rankings(data)
profile_of_rankings(as.data.frame(data))
