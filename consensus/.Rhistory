source('~/.active-rstudio-document')
library(consensus)
borda_count <- function(profileOfRankings, verbose = FALSE) {
if(verbose) {
print('Executing Borda...')
}
attname <- deparse(substitute(profileOfRankings))
# Split votes and rankings
splittedPOF <- split_profile_of_rankings(profileOfRankings)
# Get votes
votes <- splittedPOF$votes
# Get rankings
profileOfRankings <- splittedPOF$rankings
# Get the candidates
candidates <- splittedPOF$candidates
# Result vectors
v <- vector(length = ncol(profileOfRankings))
names(v) <- names(profileOfRankings)
# For each ranking in the profile of rankings
for(i in 1:nrow(profileOfRankings)) {
numVotersRow <- votes[i]
ranking <- profileOfRankings[i,]
p <- calculatePoints(ranking)
v <- v + (numVotersRow * p)
if(verbose) {
cat("-> The points for this ranking\n")
print(p)
cat("-> This ranking has ",numVotersRow," voters\n")
cat("-> The current value of the total points is:")
print(v)
}
# para candidato
# contar el número de candidatos que hay por debajo de él
# multiplicarlo por el número de votos de ese ranking
#for(c in 1:length(ranking)) {
#print(ranking)
#pos_of_c_in_the_ranking <- as.numeric(ranking[c])
#print(pos_of_c_in_the_ranking)
#lower_pos <- ranking > pos_of_c_in_the_ranking
#print(lower_pos)
#total_worse_pos <- sum(lower_pos)
#borda <- numVotersRow * total_worse_pos
#print(borda)
#v[c] <- v[c] + borda
#print('v')
#print(v)
#}
#ranking <- as.numeric(ranking)
# rpoints <- sort(unique(ranking), decreasing = TRUE)
# # - 1 for taking into account only the positions after the element and
# # not the position of the element itself
# rpoints <- as.numeric(rpoints - 1)
#
# # For each candidate in the ranking
# for(index in ranking) { # index = current candidate: a, b, c...
#   # position of the candidate "index" in the ranking
#   r <- as.numeric(ranking[index])
#   borda <- numVotersRow * rpoints[r]
#   v[index] <- v[index] + borda
# }
}
v <- sort(v, decreasing = TRUE) # sort v from more votes to less
if(verbose) {
print(paste('Points rewarded by each candidate of the profile of rankings', "'", attname, "'"))
print(v)
print('Ranking:')
}
gr <- names(v)[1] # graphic ranking
# vector that will store the final ranking
ranking <- rep(0, length(candidates))
names(ranking) <- candidates
pos <- 1 # position in the ranking
for(i in 1:(length(v)-1)) {
# gr
thisElem <- v[i]
nextElem <- v[i+1]
#print(paste('comparing', thisElem, 'with', nextElem, 'with pos', pos))
# ranking
index_of_candidate <- which(candidates == names(v)[i])
ranking[index_of_candidate] <- pos
if(thisElem > nextElem) {
gr <- paste(gr, '>',names(v)[i+1])
pos <- pos + 1
}
else { # this means the two rankings are equals
gr <- paste(gr, '~',names(v)[i+1])
}
}
ranking[which(candidates == names(v)[i+1])] <- pos
if(verbose == TRUE) {
print(gr)
}
return(ranking)
}
calculatePoints <- function(ranking, verbose = F) {
# number of different positions in the rankings
n_of_candidates <- length(ranking)
max_pos <- max(ranking)
if(n_of_candidates == max_pos) {
# the same result would be achieve with the following code
# but here the operation is vectorized so execution time decreases
if(verbose)
cat("No ties for this ranking\n")
return(n_of_candidates - ranking)
}
# vector that will store the puntuation for each category
points_by_pos <- rep(-1, max_pos)
# for each category...
for(i in 1:max_pos) {
max_interval <- n_of_candidates - 1 - sum(ranking < i)
min_interval <- max_interval - (sum(ranking == i) - 1)
points_by_pos[i] <- (max_interval+min_interval)/2
}
points_for_each_candidate <- ranking
points_for_each_candidate <- sapply(ranking, function(x) {points_by_pos[x]})
if(verbose) {
cat("The points for the ranking...\n")
print(ranking)
cat("...are:\n")
print(points_for_each_candidate)
}
return(points_for_each_candidate)
}
source('~/.active-rstudio-document')
